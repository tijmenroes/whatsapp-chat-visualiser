{"version":3,"file":"TimeSlide.vue_vue_type_script_setup_true_lang-RxuclboU.js","sources":["../../src/utils/helperFunctions.ts","../../src/components/TimeSlide.vue"],"sourcesContent":["export function divideNumber(initial: number, divideAmount: number) {\n  return parseFloat(((initial / divideAmount) * 100).toFixed(2))\n}\n\n// https://gist.github.com/robmathers/1830ce09695f759bf2c4df15c29dd22d\n// essentially the same as Object.groupBy, but that's not widely supported yet.\nexport function groupBy(data: Record<any, any>[], key: string) {\n  // `data` is an array of objects, `key` is the key (or property accessor) to group by\n  // reduce runs this anonymous function on each element of `data` (the `item` parameter,\n  // returning the `storage` parameter at the end\n  return data.reduce(function (storage, item) {\n    // get the first instance of the key by which we're grouping\n    const group = item[key]\n\n    // set `storage` for this instance of group to the outer scope (if not empty) or initialize it\n    storage[group] = storage[group] || []\n\n    // add this item to its group within `storage`\n    storage[group].push(item)\n\n    // return the updated storage to the reduce function, which will then loop through the next\n    return storage\n  }, {}) // {} is the initial value of the storage\n}\n","<template>\n  <div class=\"container\">\n    <!-- {{ data }} -->\n    <highcharts :options=\"optionsMessagesOverTime\" />\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport { Author, Message } from '../utils/types.ts'\nimport type { PropType } from 'vue'\nimport { reactive, computed } from 'vue'\nimport { groupBy } from '../utils/helperFunctions.ts'\n\nconst props = defineProps({\n  data: {\n    type: Object as PropType<Author[]>,\n    required: true,\n  },\n})\nconst series = computed(() => {\n  return props.data.map((participant) => {\n    const messages: Message[] = participant.messages\n\n    const dates = groupBy(messages, 'date')\n\n    const mappedDates = Object.entries(dates).map((item: [string, Message[]]) => {\n      const start = new Date(item[0]).setUTCHours(0, 0, 0, 0)\n      // if (new Date(start).getTime() == 'NaN' || !new Date(start).getTime()) {\n      //   console.log('NaN', item)\n      // }\n      return [new Date(start).getTime(), item[1].length]\n    })\n    return {\n      name: participant.name,\n      data: mappedDates,\n    }\n  })\n})\n\nconst optionsMessagesOverTime = reactive({\n  title: null,\n  chart: {\n    // type: '',\n    zooming: {\n      type: 'x',\n    },\n  },\n  series: computed(() => series.value),\n  xAxis: {\n    type: 'datetime',\n\n    title: {\n      text: 'Date',\n    },\n  },\n  yAxis: {\n    title: {\n      text: '',\n    },\n  },\n\n  tooltip: {\n    shared: true,\n  },\n})\n</script>\n"],"names":["divideNumber","initial","divideAmount","groupBy","data","key","storage","item","group","props","__props","series","computed","participant","messages","dates","mappedDates","start","optionsMessagesOverTime","reactive"],"mappings":"2YAAgB,SAAAA,EAAaC,EAAiBC,EAAsB,CAClE,OAAO,YAAaD,EAAUC,EAAgB,KAAK,QAAQ,CAAC,CAAC,CAC/D,CAIgB,SAAAC,EAAQC,EAA0BC,EAAa,CAI7D,OAAOD,EAAK,OAAO,SAAUE,EAASC,EAAM,CAEpC,MAAAC,EAAQD,EAAKF,CAAG,EAGtB,OAAAC,EAAQE,CAAK,EAAIF,EAAQE,CAAK,GAAK,CAAA,EAG3BF,EAAAE,CAAK,EAAE,KAAKD,CAAI,EAGjBD,CACT,EAAG,CAAE,CAAA,CACP,qGCVA,MAAMG,EAAQC,EAMRC,EAASC,EAAS,IACfH,EAAM,KAAK,IAAKI,GAAgB,CACrC,MAAMC,EAAsBD,EAAY,SAElCE,EAAQZ,EAAQW,EAAU,MAAM,EAEhCE,EAAc,OAAO,QAAQD,CAAK,EAAE,IAAKR,GAA8B,CACrE,MAAAU,EAAQ,IAAI,KAAKV,EAAK,CAAC,CAAC,EAAE,YAAY,EAAG,EAAG,EAAG,CAAC,EAI/C,MAAA,CAAC,IAAI,KAAKU,CAAK,EAAE,QAAW,EAAAV,EAAK,CAAC,EAAE,MAAM,CAAA,CAClD,EACM,MAAA,CACL,KAAMM,EAAY,KAClB,KAAMG,CAAA,CACR,CACD,CACF,EAEKE,EAA0BC,EAAS,CACvC,MAAO,KACP,MAAO,CAEL,QAAS,CACP,KAAM,GACR,CACF,EACA,OAAQP,EAAS,IAAMD,EAAO,KAAK,EACnC,MAAO,CACL,KAAM,WAEN,MAAO,CACL,KAAM,MACR,CACF,EACA,MAAO,CACL,MAAO,CACL,KAAM,EACR,CACF,EAEA,QAAS,CACP,OAAQ,EACV,CAAA,CACD"}