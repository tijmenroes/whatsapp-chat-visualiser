{"version":3,"file":"MessageWithWord-LzDCVHin.js","sources":["../../src/components/MessageWithWord.vue"],"sourcesContent":["<template>\n  <div class=\"container\">\n    <!-- <q-icon\n      v-if=\"showIcon\"\n      name=\"information\"\n      class=\"infoIcon\"\n    >\n  q-tooltip>Gekeken naar de woorden: {{ filterWords.join(', ') }}</q-tooltip>s\n    </q-icon> -->\n    <highcharts :options=\"options\" />\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport { Author, Message } from '../utils/types.ts'\nimport type { PropType } from 'vue'\nimport { reactive, computed } from 'vue'\n\nconst props = defineProps({\n  data: {\n    type: Object as PropType<Author[]>,\n    required: true,\n  },\n\n  filterWords: {\n    type: Array as PropType<string[]>,\n    required: true,\n  },\n\n  // % of messages containing one of the words\n  showRelative: {\n    type: Boolean,\n    default: false,\n  },\n\n  containsPerWord: {\n    type: Boolean,\n    default: false,\n  },\n\n  // showIcon: {\n  //   type: Boolean,\n  //   default: true,\n  // },\n})\n\nconst series = computed(() => {\n  return props.data?.map((participant) => {\n    const dataset = props.containsPerWord ? amountOfTimesPerWord(participant) : messagesContainsOneOfWord(participant)\n    const data = props.showRelative ? dataset.map((item) => parseFloat(((item / participant.messages.length) * 100).toFixed(2))) : dataset\n\n    return {\n      name: participant.name,\n      data,\n    }\n  })\n})\n\nfunction amountOfTimesPerWord(participant: Author) {\n  const amountOfTimesPerWord: number[] = []\n  props.filterWords.forEach((word) => {\n    amountOfTimesPerWord.push(participant.messages.filter((item) => item.message.includes(` ${word}`)).length)\n  })\n  return amountOfTimesPerWord\n}\n\nfunction messagesContainsOneOfWord(participant: Author) {\n  const withWords: Message[] = []\n\n  props.filterWords.forEach((word) => {\n    // See if word is included in the message and make sure it's already picked up by another word\n    withWords.push(...participant.messages.filter((item) => item.message.includes(` ${word}`) && withWords.findIndex((chosen) => chosen.id == item.id) == -1))\n  })\n\n  const data = [withWords.length]\n  return data\n}\n\nconst options = reactive({\n  title: null,\n  chart: {\n    type: 'column',\n    zooming: {\n      type: 'x',\n    },\n  },\n  series: computed(() => series.value),\n  xAxis: {\n    type: '',\n    categories: computed(() => (props.containsPerWord ? props.filterWords : props.showRelative ? ['Total in %'] : ['Total'])),\n  },\n  yAxis: {\n    title: {\n      text: '',\n    },\n  },\n\n  tooltip: {\n    shared: true,\n  },\n})\n</script>\n\n<style scoped>\n.infoIcon {\n  position: absolute;\n  top: 25px;\n  right: 0;\n}\n</style>\n"],"names":["props","__props","series","computed","_a","participant","dataset","amountOfTimesPerWord","messagesContainsOneOfWord","data","item","word","withWords","chosen","options","reactive"],"mappings":"knBAkBA,MAAMA,EAAQC,EA4BRC,EAASC,EAAS,IAAM,OAC5B,OAAOC,EAAAJ,EAAM,OAAN,YAAAI,EAAY,IAAKC,GAAgB,CACtC,MAAMC,EAAUN,EAAM,gBAAkBO,EAAqBF,CAAW,EAAIG,EAA0BH,CAAW,EAC3GI,EAAOT,EAAM,aAAeM,EAAQ,IAAKI,GAAS,YAAaA,EAAOL,EAAY,SAAS,OAAU,KAAK,QAAQ,CAAC,CAAC,CAAC,EAAIC,EAExH,MAAA,CACL,KAAMD,EAAY,KAClB,KAAAI,CAAA,CACF,EACD,CACF,EAED,SAASF,EAAqBF,EAAqB,CACjD,MAAME,EAAiC,CAAA,EACjC,OAAAP,EAAA,YAAY,QAASW,GAAS,CAClCJ,EAAqB,KAAKF,EAAY,SAAS,OAAQK,GAASA,EAAK,QAAQ,SAAS,IAAIC,CAAI,EAAE,CAAC,EAAE,MAAM,CAAA,CAC1G,EACMJ,CACT,CAEA,SAASC,EAA0BH,EAAqB,CACtD,MAAMO,EAAuB,CAAA,EAEvB,OAAAZ,EAAA,YAAY,QAASW,GAAS,CAExBC,EAAA,KAAK,GAAGP,EAAY,SAAS,OAAQK,GAASA,EAAK,QAAQ,SAAS,IAAIC,CAAI,EAAE,GAAKC,EAAU,UAAWC,GAAWA,EAAO,IAAMH,EAAK,EAAE,GAAK,EAAE,CAAC,CAAA,CAC1J,EAEY,CAACE,EAAU,MAAM,CAEhC,CAEA,MAAME,EAAUC,EAAS,CACvB,MAAO,KACP,MAAO,CACL,KAAM,SACN,QAAS,CACP,KAAM,GACR,CACF,EACA,OAAQZ,EAAS,IAAMD,EAAO,KAAK,EACnC,MAAO,CACL,KAAM,GACN,WAAYC,EAAS,IAAOH,EAAM,gBAAkBA,EAAM,YAAcA,EAAM,aAAe,CAAC,YAAY,EAAI,CAAC,OAAO,CAAE,CAC1H,EACA,MAAO,CACL,MAAO,CACL,KAAM,EACR,CACF,EAEA,QAAS,CACP,OAAQ,EACV,CAAA,CACD"}